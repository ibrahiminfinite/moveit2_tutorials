Realtime Servo
============

MoveIt Servo facilitates realtime control of your robot arm.

Servo accepts any of the following types of commands:
    1. Individual joint velocities.
    2. The desired velocity of end-effector.
    3. The desired pose of end-effector.

This enables teleoperation via a wide range of input schemes, or for other autonomous software to control the robot - in visual servoing or closed loop position control for instance.

Getting Started
---------------

If you haven't already done so, make sure you've completed the steps in :doc:`Getting Started </doc/tutorials/getting_started/getting_started>`.


Design overview
--------------

Moveit Servo consists of two main parts, the core Servo implementation which provides a C++ interface, and the ServoNode which
wraps the C++ interface and provides a ROS interface.

The configuration of Servo is done through ROS parameters specified in `servo_parameters.yaml <https://github.com/ros-planning/moveit2/blob/main/moveit_ros/moveit_servo/config/servo_parameters.yaml>`_

Using the C++ API
------------------
The C++ API allows the user to create and utilize an instance of Servo within their C++ programs.
This can be beneficial when there is a performance requirement to avoid the overhead of ROS communication infrastucture,
or when the output generated by Servo needs to be fed into some other controller running in C++ without a ROS API.

When using Servo with the C++ interface the three input command types are:
    1. JointJogCommand
    2. TwistCommand
    3. PoseCommand

As given by the definitions in `datatypes <https://github.com/ros-planning/moveit2/blob/main/moveit_ros/moveit_servo/include/moveit_servo/utils/datatypes.hpp>`_ header file.
The output from Servo when using the C++ interface is `KinematicState`, a struct containing joint names, positions, velocities and accelerations.

The first step is to create a Servo instance.

.. code-block:: c++

    #include <moveit_servo/servo.hpp>
    #include <moveit_servo/utils/common.hpp>

    int main(int argc, char* argv[])
    {
        rclcpp::init(argc, argv);
        rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("servo_tutorial");

        // Get the Servo parameters.
        const std::string param_namespace = "moveit_servo";
        const std::shared_ptr<const servo::ParamListener> servo_param_listener =
            std::make_shared<const servo::ParamListener>(node, param_namespace);
        const servo::Params servo_params = servo_param_listener->get_params();

        // Create the planning scene monitor.
        const planning_scene_monitor::PlanningSceneMonitorPtr planning_scene_monitor =
            createPlanningSceneMonitor(node, servo_params);

        // Create a Servo instance.
        Servo servo = Servo(node, servo_param_listener, planning_scene_monitor);
    }


Using the ROS API
-----------------

To use Servo through the ROS interface, it must be launched as a `Node` or `Component` along with the required parameters.

When using Servo with the ROS interface the commands are ROS messages of the following types published to respective topics specified by the Servo parameters.
    1. control_msgs::msg::JointJog on the topic specified by *joint_command_in_topic* parameter.
    2. geometry_msgs::msg::TwistStamped on the topic specified by *cartesian_command_in_topic* parameter.
    3. geometry_msgs::msg::PoseStamped on the topic specified by *pose_command_in_topic* parameter.

The output from Servo can either be trajectory_msgs::msg::JointTrajectory or std_msgs::msg::Float64MultArray
selected using the *command_out_type* published on the topic specified by *command_out_topic* parameter.
