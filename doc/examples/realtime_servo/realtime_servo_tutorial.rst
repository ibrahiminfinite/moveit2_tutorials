Realtime Servo
============

MoveIt Servo facilitates realtime control of your robot arm.

Servo accepts any of the following types of commands:

    1. Individual joint velocities.
    2. The desired velocity of end-effector.
    3. The desired pose of end-effector.

This enables teleoperation via a wide range of input schemes, or for other autonomous software to control the robot - in visual servoing or closed loop position control for instance.

Getting Started
---------------

If you haven't already done so, make sure you've completed the steps in :doc:`Getting Started </doc/tutorials/getting_started/getting_started>`.


Design overview
--------------

Moveit Servo consists of two main parts, the core implementation `Servo` which provides a C++ interface, and the `ServoNode` which
wraps the C++ interface and provides a ROS interface.

The configuration of Servo is done through ROS parameters specified in `servo_parameters.yaml <https://github.com/ros-planning/moveit2/blob/main/moveit_ros/moveit_servo/config/servo_parameters.yaml>`_

In addition to the servoing capability, MoveIt Servo has some convenient features such as:

    - Checking for singularities
    - Checking for collisions

The collision checking is an optional feature that can be disabled using the `check_collisions` parameter.

Using the C++ API
------------------
The C++ interface allows the user to create and utilize an instance of Servo within their C++ programs.
This can be beneficial when there is a performance requirement to avoid the overhead of ROS communication infrastucture,
or when the output generated by Servo needs to be fed into some other controller that does not have a ROS interface.

When using Servo with the C++ interface the three input command types are `JointJogCommand`, `TwistCommand` and `PoseCommand`.
The output from Servo when using the C++ interface is `KinematicState`, a struct containing joint names, positions, velocities and accelerations.
As given by the definitions in `datatypes <https://github.com/ros-planning/moveit2/blob/main/moveit_ros/moveit_servo/include/moveit_servo/utils/datatypes.hpp>`_ header file.

The first step is to create a Servo instance.

.. code-block:: c++

    // Import the Servo headers.
    #include <moveit_servo/servo.hpp>
    #include <moveit_servo/utils/common.hpp>

.. code-block:: c++

    // The node to be used by Servo.
    rclcpp::Node::SharedPtr node = std::make_shared<rclcpp::Node>("servo_tutorial");

.. code-block:: c++

    // Get the Servo parameters.
    const std::string param_namespace = "moveit_servo";
    const std::shared_ptr<const servo::ParamListener> servo_param_listener =
        std::make_shared<const servo::ParamListener>(node, param_namespace);
    const servo::Params servo_params = servo_param_listener->get_params();

.. code-block:: c++

    // Create the planning scene monitor.
    const planning_scene_monitor::PlanningSceneMonitorPtr planning_scene_monitor =
        createPlanningSceneMonitor(node, servo_params);

.. code-block:: c++

    // Create a Servo instance.
    Servo servo = Servo(node, servo_param_listener, planning_scene_monitor);


Using the JointJogCommand

.. code-block:: c++

    using namespace moveit_servo;

    // Create the command.
    JointJogCommand command;
    command.joint_names = {"panda_link7"};
    command.velocities = {0.1};

    // Set JointJogCommand as the input type.
    servo.setCommandType(CommandType::JOINT_JOG);

    // Get the joint states required to follow the command.
    // This is generally run in a loop.
    KinematicState next_joint_state = servo.getNextJointState(command);

Using the TwistCommand

.. code-block:: c++

    using namespace moveit_servo;

    // Create the command.
    TwistCommand command{"panda_link0", {0.1, 0.0, 0.0, 0.0, 0.0, 0.0};

    // Set the command type.
    servo.setCommandType(CommandType::TWIST);

    // Get the joint states required to follow the command.
    // This is generally run in a loop.
    KinematicState next_joint_state = servo.getNextJointState(command);


Using the PoseCommand

.. code-block:: c++

    using namespace moveit_servo;

    // Create the command.
    Eigen::Isometry3d ee_pose = Eigen::Isometry3d::Identity(); // This is a dummy pose.
    PoseCommand command{"panda_link0", ee_pose};

    // Set the command type.
    servo.setCommandType(CommandType::POSE);

    // Get the joint states required to follow the command.
    // This is generally run in a loop.
    KinematicState next_joint_state = servo.getNextJointState(command);

The `next_joint_state` result can then be used for further steps in the control pipeline.

The status of Servo resulting from the last command can be obtained by:

.. code-block:: c++

    StatusCode status = servo.getStatus();

The satus can be used as input for various decisions.

See `here <https://github.com/ros-planning/moveit2/tree/main/moveit_ros/moveit_servo/demos/cpp_interface>`_ for complete examples of using the C++ interface.
The demos can be launched using the launch files found `here <https://github.com/ros-planning/moveit2/tree/main/moveit_ros/moveit_servo/launch>`_.

    - `ros2 launch moveit_servo demo_joint_jog.launch.py``
    - `ros2 launch moveit_servo demo_twist.launch.py`
    - `ros2 launch moveit_servo demo_pose.launch.py`


Using the ROS API
-----------------

To use Servo through the ROS interface, it must be launched as a **Node** or **Component** along with the required parameters as seen `here <https://github.com/ros-planning/moveit2/blob/main/moveit_ros/moveit_servo/launch/demo_ros_api.launch.py>`_.

When using Servo with the ROS interface the commands are ROS messages of the following types published to respective topics specified by the Servo parameters.

    1. `control_msgs::msg::JointJog` on the topic specified by *joint_command_in_topic* parameter.
    2. `geometry_msgs::msg::TwistStamped` on the topic specified by *cartesian_command_in_topic* parameter.
    3. `geometry_msgs::msg::PoseStamped` on the topic specified by *pose_command_in_topic* parameter.

The output from Servo can either be `trajectory_msgs::msg::JointTrajectory`` or `std_msgs::msg::Float64MultiArray`
selected using the *command_out_type* parameter, and published on the topic specified by *command_out_topic* parameter.

The command type for Servo can be selected using the `ServoCommandType` service, see definition `here <https://github.com/ros-planning/moveit_msgs/blob/ros2/srv/ServoCommandType.srv>`_.

From cli : `ros2 service call /servo_node/switch_command_type moveit_msgs/srv/ServoCommandType "{command_type: 1}"`

Programmatically:

.. code-block:: c++

        swith_input_client = node->create_client<moveit_msgs::srv::ServoCommandType>("servo_node/switch_command_type");
        auto request = std::make_shared<moveit_msgs::srv::ServoCommandType::Request>();
        request->command_type = moveit_msgs::srv::ServoCommandType::Request::TWIST;
        if (swith_input_client->wait_for_service(std::chrono::seconds(1)))
        {
          auto result = swith_input_client->async_send_request(request);
          if (result.get()->success)
          {
            RCLCPP_INFO_STREAM(node->get_logger(), "Switched to input type: Twist");
          }
          else
          {
            RCLCPP_WARN_STREAM(node->get_logger(), "Could not switch input to: Twist");
          }
        }

Similarly, Servo can be paused using the pause service of type `std_msgs::srv::SetBool`.

When using the ROS interface, the status of Servo is available on the topic `/servo_node/status`, see definition `here <https://github.com/ros-planning/moveit_msgs/blob/ros2/msg/ServoStatus.msg>`_.

Launch ROS interface demo: `ros2 launch moveit_servo demo_ros_api.launch.py`.

Once the demo is running, the robot can be teleoperated through the keyboard.

Launch the keyboard demo: `ros2 run moveit_servo servo_keyboard_input`.

An example of using the pose commands in the context of servoing to open a door can be seen `here <https://github.com/ros-planning/moveit2_tutorials/blob/main/doc/examples/realtime_servo/src/pose_tracking_tutorial.cpp>`_.
